/**
 * @file bigint
 * @brief A single-header C++ BigInteger implementation.
 * 
 * Copyright (c) 2025, Torelis.  All rights reserved.
 *
 * This file defines a BigInteger class that supports arbitrary-precision
 * integer arithmetic and comparison operations, exceeding the limits of
 * built-in integer types.
 *
 * Arbitrary-precision integer representation.
 * Basic arithmetic operations: addition, subtraction, multiplication
 * and division.
 * Comparison operators (==, !=, <, <=, >, >=).
 * Policy-based design for base/radix and storage (extensible).
 * Header-only, no external dependencies.
 */

#pragma once

/// This file uses C++11 features such as using type aliases and constexpr
/// variables and functions, so a C++11 compatible compiler is required.
#if __cplusplus < 201103L
  #error "This project requires C++11 or higher"
#endif

#include <type_traits>
#include <cstdint>
#include <vector>
#include <sstream>          // for stringstream
#include <iomanip>          // for setw(), setfill()
#include <algorithm>        // for reverse()

namespace torelis
{
/**
 * @brief Numeric Policy for BigInteger.
 *
 * The Numeric Policy defines how digits of a BigInteger are represented
 * and managed internally. In other words, it specifies the numeric base
 * (radix) and related operations used for storing and manipulating
 * large integers.
 * 
 * For different number radices, it is only necessary to
 * define three compiler constants in the derived class,
 * namely RADIX, DIGITS_PER_BLOCK, and BASE.
 */
struct NumericBase
{
    typedef uint16_t radix_type;
    typedef uint64_t base_type;

    /**
     * @brief Converts a numeric string from one radix to another.
     *
     * @param str The input numeric string to convert.
     * @param from The radix of the input string.
     * @param to The target radix to convert to.
     * @return The converted numeric string in the target radix.
     */
    static std::string
    S_radix_convert(const std::string& str, radix_type from, radix_type to)
    {
        if ((from >= 2 && from <= 36) && (to >= 2 && to <= 36))
        {
            std::string temp = S_to_decimal(str, from);
            return S_to_radix(temp, to);
        }
        throw std::invalid_argument("Radix must in [2, 36]");
    }

private:
    // Converts a character to its numeric digit value.
    static int S_to_digit(char c)
    {
        uint8_t uc = static_cast<uint8_t>(c);
        if (std::isdigit(uc))
            return uc - '0';
        else if (std::isalpha(uc))
        {
            uc = static_cast<uint8_t>(std::toupper(uc));
            return uc - 'A' + 10;
        }
        throw std::invalid_argument("Must be 0-9, a-z, or A-Z");
    }

    // Converts a numeric digit to its character representation.
    static char S_to_char(int digit)
    {
        if (0 <= digit && digit <= 9)
            return static_cast<char>('0' + digit);
        if (10 <= digit && digit <= 35)
            return static_cast<char>('A' + (digit - 10));
        throw std::invalid_argument("Must in [0, 35]");
    }

    // Converts a string in a given radix to its
    // decimal string representation.
    static std::string
    S_to_decimal(const std::string& str, radix_type radix)
    {
        size_t pos{0};
        bool positive{true};
        if (!str.empty() && str[0] == '-')
        {
            positive = false;
            pos++;
        }
        std::string ret{"0"};
        for (; pos < str.size(); ++pos)
        {
            std::string temp{ret};
            int carry = S_to_digit(str[pos]);;
            for (int64_t i = (int64_t)temp.size() - 1; i >= 0; --i)
            {
                int sum = (temp[i] - '0') * radix + carry;
                temp[i] = static_cast<char>((sum % 10) + '0');
                carry = sum / 10;
            }
            while (carry)
            {
                temp.insert(temp.begin(),
                    static_cast<char>(carry % 10 + '0'));
                carry /= 10;
            }
            ret = temp;
        }
        if (!positive)
            ret.insert(ret.begin(), '-');
        return ret;
    }

    // Converts a decimal string to a string in the specified radix.
    static std::string
    S_to_radix(const std::string& str, radix_type radix)
    {
        bool positive{true};
        std::string s{str};
        if (!s.empty() && s[0] == '-')
        {
            positive = false;
            s.erase(s.begin());
        }

        std::string ret{};
        std::string next{};
        for (; ; )
        {
            int carry = 0;
            next.clear();
            for (const char c : s)
            {
                int x = carry * 10 + (c - '0');
                next.push_back(static_cast<char>((x / radix) + '0'));
                carry = x % radix;
            }
            ret.push_back(S_to_char(carry));

            auto pos = next.find_first_not_of('0');
            if (pos == std::string::npos)
                break;
            s = next.substr(pos);
        }
        if (ret.empty())
            ret = "0";
        else
            std::reverse(ret.begin(), ret.end());
        if (!positive)
            ret.insert(ret.begin(), '-');
        return ret;
    }
};

// block-wise storage with base (10 ^ 9)
struct Decimal : public NumericBase
{
    /* BASE = RADIX ^ DIGITS_PER_BLOCK */
    // radix, such as decimal, hexadecimal, etc.
    static constexpr radix_type RADIX = 10U;
    static constexpr unsigned DIGITS_PER_BLOCK = 9U;
    // base, the value of each data block is in the range [0, BASE - 1]
    static constexpr base_type BASE = 1000000000U;
};

/**
 * @brief Storage Policy for BigInteger.
 *
 * @tparam T The type of elements stored in the container.
 * This can be any copyable or movable type that the container will hold.
 * 
 * The Storage Policy defines how the sequence of digits (blocks)
 * of a BigInteger is stored in memory. It abstracts away the underlying
 * container and memory management, allowing flexibility in performance,
 * memory usage, and custom allocation strategies.
 *
 * Separates the storage mechanism from arithmetic logic.
 * Allows swapping different containers (e.g., std::vector, std::deque,
 * custom allocator).
 * Supports dynamic resizing, insertion, and removal of digit blocks.
 * 
 * @note If an STL container is used as the storage policy, it can
 * be passed directly to the BigInteger template class via the first
 * template parameter. Only when managing the storage policy manually
 * is it necessary to implement a Storage class (or struct).
 */
template <typename T>
struct Storage
{
};

/**
 * @brief Arbitrary-precision integer class using policy-based design.
 *
 * @tparam Storage  Defines how the sequence of digit blocks is
 * stored in memory.
 * eg., dynamic array(std::vector), fixed-size array, or custom allocator.
 * @tparam Numeric  Defines the numeric base (radix) and digit
 * representation. Must be derived from NumericBase.
 * eg., Decimal (blocks of 10 ^ 9).
 *
 * @details
 * The BigInteger class provides arithmetic and comparison operations for
 * integers beyond the limits of built-in types. It separates the storage
 * mechanism and digit representation from arithmetic logic using policies,
 * making it modular and adaptable.
 * 
 * @note When providing Storage and Numeric, please ensure
 * that for any number x, with BASE = Numeric::BASE and
 * TYPE = Storage::value_type, it holds that
 * (x % BASE) <= std::numeric_limits<TYPE>::max().
 */
template <typename Storage
        , typename Numeric
        , typename = std::__enable_if_t  // std::enable_if_t for C++11
    <std::is_base_of<NumericBase, Numeric>::value>>
class BigInteger
{
private:
    typedef typename Storage::value_type    value_type;
    typedef typename Storage::size_type     size_type;
    typedef typename Storage::difference_type difference_type;
    typedef Numeric::base_type     base_type;
    typedef Numeric::radix_type    radix_type;
    typedef int64_t                wide_type;
    typedef uint64_t               uwide_type;

    using self_type = BigInteger<Storage, Numeric>;
    using self_reference = self_type&;
    using const_self_reference = const self_type&;
    using r_self_reference = self_type&&;

    // Alias for the type of the pointer to Numeric::S_radix_convert
    using f_radix_convert_t = decltype(&Numeric::S_radix_convert);

protected:
    static constexpr base_type BASE    = Numeric::BASE;
    static constexpr unsigned SIZE     = Numeric::DIGITS_PER_BLOCK;
    static constexpr radix_type RADIX  = Numeric::RADIX;
    static constexpr f_radix_convert_t
                f_radix_convert = &Numeric::S_radix_convert;

public:
    // constructors
    BigInteger() // = default;
    : M_storage()
    , M_positive(true)
    { }

    BigInteger(int64_t integer)
    {
        (void)(M_from_integer(integer));
    }

    BigInteger(const std::string& str, radix_type radix = RADIX)
    {
        if (radix != RADIX)
        {
            std::string s = f_radix_convert(str, radix, RADIX);
            (void)(M_from_string(s));
            return ;
        }
        (void)(M_from_string(str));
    }

    template <typename Cstr
            , typename = std::__enable_if_t
        <std::is_same<Cstr, const char*>::value>>
    BigInteger(Cstr cstr, radix_type radix = RADIX)
    : BigInteger(std::string(cstr), radix)
    { }

    BigInteger(const_self_reference other)
    : M_storage(other.M_storage)
    , M_positive(other.M_positive)
    { }

    BigInteger(r_self_reference other) noexcept
    : M_storage(std::move(other.M_storage))
    , M_positive(other.M_positive)
    { }

    // destructor
    ~BigInteger() = default;

    /// assignment operator overload
    // Assigns the BigInteger from a 64-bit integer.
    self_reference operator=(int64_t integer)
    {
        return M_from_integer(integer);
    }

    /// operator=(const std::string&)
    ///   Assigns the BigInteger from a string;
    /// operator=(const char* cstr)
    ///   Assigns the BigInteger from a C-style string.
    /// Defaults to decimal radix; for non-decimal, use
    /// the corresponding constructor.
    self_reference operator=(const std::string& str)
    {
        return M_from_string(str);
    }

    template <typename Cstr
            , typename = typename std::enable_if
        <std::is_same<Cstr, const char*>::value>::type>
    self_reference operator=(Cstr cstr)
    {
        return M_from_string(cstr);
    }

    self_reference operator=(const_self_reference other)
    {
        if (this != &other)
        {
            M_storage = other.M_storage;
            M_positive = other.M_positive;
        }
        return *this;
    }

    self_reference operator=(r_self_reference other) noexcept
    {
        if (this != &other)
        {
            M_storage = std::move(other.M_storage);
            M_positive = other.M_positive;
        }
        return *this;
    }

    /* public functions accessible externally */
    /// the four basic arithmetic operations
    /// addition
    /**
     * @brief Returns the sum of two BigIntegers.
     * @param lhs The left-hand side BigInteger.
     * @param rhs The right-hand side BigInteger.
     * @return A new BigInteger representing the sum.
     */
    friend self_type
    operator+(const_self_reference lhs, const_self_reference rhs)
    {
        if (lhs.M_positive == rhs.M_positive)
        {
            self_type r = lhs;
            r.M_add_abs(rhs);
            return r;
        }
        int cmp = lhs.M_compare_abs(rhs);
        if (cmp == 0)
            return static_cast<self_type>(0);
        if (cmp > 0)
        {
            self_type r = lhs;
            r.M_subtract_abs(rhs);
            return r;
        }
        self_type r = rhs;
        r.M_subtract_abs(lhs);
        return r;
    }

    /**
     * @brief Adds another BigInteger to this one.
     * @param integer The BigInteger to add.
     * @return Reference to this BigInteger after addition.
     */
    self_reference operator+=(const_self_reference integer)
    {
        *this = *this + integer;
        return *this;
    }

    /// subtraction
    /**
     * @brief Returns the difference between two BigIntegers.
     * @param lhs The left-hand side BigInteger.
     * @param rhs The right-hand side BigInteger.
     * @return A new BigInteger representing the difference.
     */
    friend self_type
    operator-(const_self_reference lhs, const_self_reference rhs)
    {
        if (lhs.M_positive != rhs.M_positive)
        {
            self_type r = lhs;
            r.M_add_abs(rhs);
            return r;
        }
        int cmp = lhs.M_compare_abs(rhs);
        if (cmp == 0)
            return static_cast<self_type>(0);
        if (cmp > 0)
        {
            self_type r = lhs;
            r.M_subtract_abs(rhs);
            return r;
        }
        self_type r = rhs;
        r.M_subtract_abs(lhs);
        r.M_positive = !r.M_positive;
        return r;
    }

    /**
     * @brief Subtracts another BigInteger from this one.
     * @param integer The BigInteger to subtract.
     * @return Reference to this BigInteger after subtraction.
     */
    self_reference operator-=(const_self_reference integer)
    {
        *this = *this - integer;
        return *this;
    }

    /// multiplication
    /**
     * @brief Returns the product of two BigIntegers.
     * @param lhs The left-hand side BigInteger.
     * @param rhs The right-hand side BigInteger.
     * @return A new BigInteger representing the product.
     */
    friend self_type
    operator*(const_self_reference lhs, const_self_reference rhs)
    {
        self_type r = S_multiply_abs(lhs, rhs);
        r.M_positive = !(lhs.M_positive ^ rhs.M_positive);
        if (r.M_zero())
            r.M_positive = true;
        return r;
    }

    /**
     * @brief Multiplies this BigInteger by another.
     * @param integer The BigInteger to multiply with.
     * @return Reference to this BigInteger after multiplication.
     */
    self_reference operator*=(const_self_reference integer)
    {
        *this = *this * integer;
        return *this;
    }

    /// division
    /**
     * @brief Returns the quotient of two BigIntegers.
     * @param lhs The dividend BigInteger.
     * @param rhs The divisor BigInteger.
     * @return A new BigInteger representing the quotient.
     */
    friend self_type
    operator/(const_self_reference lhs, const_self_reference rhs)
    {
        return S_divmod(lhs, rhs).first;
    }

    /**
     * @brief Divides this BigInteger by another.
     * @param integer The BigInteger to divide by.
     * @return Reference to this BigInteger after division.
     */
    self_reference operator/=(const_self_reference integer)
    {
        *this = *this / integer;
        return *this;
    }

    /// modulo
    /**
     * @brief Returns the remainder of division between two BigIntegers.
     * @param lhs The dividend BigInteger.
     * @param rhs The divisor BigInteger.
     * @return A new BigInteger representing the remainder.
     */
    friend self_type
    operator%(const_self_reference lhs, const_self_reference rhs)
    {
        return S_divmod(lhs, rhs).second;
    }

    /**
     * @brief Computes the remainder of this BigInteger divided by another.
     * @param integer The BigInteger to divide by.
     * @return Reference to this BigInteger after modulo operation.
     */
    self_reference operator%=(const_self_reference integer)
    {
        *this = *this % integer;
        return *this;
    }

    /// increment and decrement operators
    /**
     * @brief Pre-increments this BigInteger by 1.
     * @return Reference to this BigInteger after increment.
     */
    self_reference operator++()
    {
        *this += static_cast<self_type>(1);
        return *this;
    }

    /**
     * @brief Post-increments this BigInteger by 1.
     * @param int Dummy parameter to distinguish post-increment.
     * @return A copy of the BigInteger before increment.
     */
    self_type operator++(int)
    {
        self_type r = *this;
        *this += static_cast<self_type>(1);
        return r;
    }

    /**
     * @brief Pre-decrements this BigInteger by 1.
     * @return Reference to this BigInteger after decrement.
     */
    self_reference operator--()
    {
        *this -= static_cast<self_type>(1);
        return *this;
    }

    /**
     * @brief Post-decrements this BigInteger by 1.
     * @param int Dummy parameter to distinguish post-decrement.
     * @return A copy of the BigInteger before decrement.
     */
    self_type operator--(int)
    {
        self_type r = *this;
        *this -= static_cast<self_type>(1);
        return r;
    }

    /// comparisons
    /**
     * @brief Checks if lhs is less than rhs.
     * @return true if lhs < rhs, otherwise false.
     */
    friend bool
    operator<(const_self_reference lhs, const_self_reference rhs)
    {
        if (lhs.M_positive != rhs.M_positive)
            return rhs.M_positive;
        int cmp = lhs.M_compare_abs(rhs);
        return (lhs.M_positive ? cmp < 0 : cmp > 0);
    }

    /**
     * @brief Checks if lhs is less than or equal to rhs.
     * @return true if lhs <= rhs, otherwise false.
     */
    friend bool
    operator<=(const_self_reference lhs, const_self_reference rhs)
    {
        return !(rhs < lhs);
    }

    /**
     * @brief Checks if lhs is greater than rhs.
     * @return true if lhs > rhs, otherwise false.
     */
    friend bool
    operator>(const_self_reference lhs, const_self_reference rhs)
    {
        return rhs < lhs;
    }

    /**
     * @brief Checks if lhs is greater than or equal to rhs.
     * @return true if lhs >= rhs, otherwise false.
     */
    friend bool
    operator>=(const_self_reference lhs, const_self_reference rhs)
    {
        return !(lhs < rhs);
    }

    /**
     * @brief Checks if lhs is equal to rhs.
     * @return true if lhs == rhs, otherwise false.
     */
    friend bool
    operator==(const_self_reference lhs, const_self_reference rhs)
    {
        return (lhs.M_positive == rhs.M_positive
             && lhs.M_storage == rhs.M_storage);
    }

    /**
     * @brief Checks if lhs is not equal to rhs.
     * @return true if lhs != rhs, otherwise false.
     */
    friend bool
    operator!=(const_self_reference lhs, const_self_reference rhs)
    {
        return !(lhs == rhs);
    }

    /// stream IO
    /**
     * @brief Reads a BigInteger from a stream.
     */
    friend std::istream&
    operator>>(std::istream& is, self_reference integer)
    {
        std::string s{};
        if (!(is >> s))
            return is;
        integer.M_from_string(s);
        return is;
    }

    /**
     * @brief Outputs the BigInteger to a stream.
     */
    friend std::ostream&
    operator<<(std::ostream& os, const_self_reference integer)
    {
        os << integer.to_string();
        return os;
    }

    /**
     * @brief Converts to true if the BigInteger
     * is non-zero, otherwise false.
     */
    explicit operator bool() const noexcept
    {
        return !M_zero();
    }

    /**
     * @brief Returns the negation of this BigInteger.
     * @return A new BigInteger with the opposite sign.
     */
    self_type operator-() const
    {
        self_type r = *this;
        if (r.M_zero())
            r.M_positive = !r.M_positive;
        return r;
    }

    /**
     * @brief Returns the absolute value of this BigInteger.
     * @return A new BigInteger representing the absolute value.
     */
    self_type abs() const
    {
        self_type r = *this;
        r.M_positive = true;
        return r;
    }

    /**
     * @brief Returns the sign of the BigInteger.
     * @return 1 if positive, -1 if negative, 0 if zero.
     */
    int sign() const
    {
        if (M_zero())
            return 0;
        return (M_positive ? 1 : -1);
    }

    /**
     * @brief Converts the BigInteger to its string representation.
     * @return A string representing the value of the BigInteger.
     */
    std::string to_string() const
    {
        if (M_zero())
            return "0";
        std::stringstream ss{};
        if (!M_positive)
            ss << '-';
        ss << (M_storage.empty() ? 0 : M_storage.back());
        for (auto it = M_storage.rbegin() + 1; it != M_storage.rend(); ++it)
        {
            ss << std::setw(SIZE) << std::setfill('0') << (*it);
        }
        return ss.str();
    }

private:
    /**
     * @brief Removes unnecessary leading zeros from the BigInteger.
     *
     * After arithmetic operations (addition, subtraction, multiplication
     * , etc.), the highest digits may become zero without affecting the
     * actual value. This function trims those unnecessary leading zeros
     * to maintain a normalized state.
     */
    void M_trim() noexcept
    {
        while (!M_storage.empty() && M_storage.back() == 0)
            M_storage.pop_back();
        if (M_storage.empty()) // zero is positive
            M_positive = true;
    }

    /**
     * @brief Resets the BigInteger to zero.
     *
     * Clears all internal data and sets the value to 0.
     */
    void M_reset() noexcept
    {
        M_storage.clear();
        M_positive = true;
    }

    /**
     * @brief Initializes the BigInteger from a 64-bit integer.
     * @param integer The 64-bit integer to convert.
     * @return Reference to the current BigInteger.
     */
    self_reference M_from_integer(int64_t integer)
    {
        M_reset();
        if (integer < 0)
        {
            M_positive = false;
            integer = -integer;
        }
        while (integer)
        {
            value_type x = static_cast<value_type>(integer % BASE);
            M_storage.push_back(x);
            integer /= BASE;
        }
        return *this;
    }

    /**
     * @brief Initializes the BigInteger from a string representation.
     *
     * Parses the input string and sets the BigInteger value accordingly.
     *
     * @param str The string containing the numeric value.
     * @return Reference to the current BigInteger.
     */
    self_reference M_from_string(const std::string& str)
    {
        M_reset();
        size_t pos{0}, n = str.size();
        for (; pos < n && isspace((unsigned char)str[pos]); ++pos);
        if (pos < n && (str[pos] == '+' || str[pos] == '-'))
        {
            M_positive = (str[pos] == '+');
            ++pos;
        }
        for (ptrdiff_t i{static_cast<ptrdiff_t>(n) - 1};
             i >= static_cast<ptrdiff_t>(pos);
             i -= static_cast<ptrdiff_t>(SIZE))
        {
            value_type x = 0;
            // size_t l = std::max(pos, i - SIZE + 1);
            ptrdiff_t l = std::max((ptrdiff_t)pos, i - (ptrdiff_t)SIZE + 1);
            for (ptrdiff_t j = l; j <= i; ++j)
            {
                if (!isdigit((unsigned char)str[j]))
                    throw std::invalid_argument("Invalid digit");
                x = x * RADIX + (str[j] - '0');
            }
            M_storage.push_back(x);
        }
        M_trim();
        return *this;
    }

    /**
     * @brief Compares the absolute value of this BigInteger with another.
     * @param other The BigInteger to compare with.
     * @return A positive value if |this| > |other|, zero if
     * |this| == |other|, or a negative value if |this| < |other|.
     */
    int M_compare_abs(const_self_reference other) const
    {
        if (M_storage.size() != other.M_storage.size())
            return (M_storage.size() < other.M_storage.size() ? -1 : 1);
        for (size_type i = M_storage.size() - 1; i >= 0; --i)
        {
            if (M_storage[i] != other.M_storage[i])
                return (M_storage[i] < other.M_storage[i] ? -1 : 1);
        }
        return 0;
    }

    /**
     * @brief Adds another BigInteger's absolute value to this one.
     * @param other The BigInteger whose absolute value will be added.
     */
    void M_add_abs(const_self_reference other)
    {
        uwide_type carry{0};
        size_type n = std::max(M_storage.size(), other.M_storage.size());
        if (M_storage.size() < n)
            M_storage.resize(n, 0);
        for (size_type i{0}; i < n; ++i)
        {
            uwide_type sum = carry + M_storage[i]
                + (i < other.M_storage.size() ? other.M_storage[i] : 0);
            M_storage[i] = static_cast<value_type>(sum % BASE);
            carry = sum / BASE;
        }
        if (carry)
            M_storage.push_back(static_cast<value_type>(carry));
    }

    /**
     * @brief Subtracts another BigInteger's absolute value from this one.
     * @param other The BigInteger whose absolute value will be subtracted.
     */
    void M_subtract_abs(const_self_reference other)
    {
        wide_type carry{0};
        for (size_type i{0}; i < other.M_storage.size() || carry; ++i)
        {
            wide_type curr = (wide_type)M_storage[i]
                - (i < other.M_storage.size() ? other.M_storage[i] : 0)
                - carry;
            if (curr < 0)
            {
                curr += BASE;
                carry = 1;
            }
            else
                carry = 0;
            M_storage[i] = static_cast<value_type>(curr);
        }
        M_trim();
    }

    /**
     * @brief Returns the product of the absolute values of two BigIntegers.
     * @param lhs The first BigInteger.
     * @param rhs The second BigInteger.
     * @return A BigInteger representing |lhs| * |rhs|.
     */
    static self_type
    S_multiply_abs(const_self_reference lhs, const_self_reference rhs)
    {
        if (lhs.M_zero() || rhs.M_zero())
            return self_type(0);
        self_type ret{};
        ret.M_storage.assign(lhs.M_storage.size() + rhs.M_storage.size(), 0);
        for (size_type i{0}; i < lhs.M_storage.size(); ++i)
        {
            uwide_type carry{0};
            uwide_type xi = static_cast<uwide_type>(lhs.M_storage[i]);
            for (size_type j{0}; j < rhs.M_storage.size() || carry; ++j)
            {
                uwide_type curr = carry + ret.M_storage[i + j]
                    + xi * (j < rhs.M_storage.size()
                    ? uwide_type(rhs.M_storage[j]) : 0);
                ret.M_storage[i + j] = static_cast<value_type>(curr % BASE);
                carry = curr / BASE;
            }
        }
        ret.M_trim();
        return ret;
    }

    /**
     * @brief Divides two BigIntegers and returns both quotient and remainder.
     * @param dividend The number to be divided.
     * @param divisor The number to divide by.
     * @return A pair containing {quotient, remainder}.
     */
    static std::pair<self_type, self_type>
    S_divmod(const_self_reference dividend, const_self_reference divisor)
    {
        if (divisor.M_zero())
            throw std::runtime_error("Division by zero");
        self_type a = dividend.abs();
        self_type b = divisor.abs();
        if (a.M_compare_abs(b) < 0)
        {
            return {self_type(0), dividend};
        }
        size_t n = a.M_storage.size();
        size_t m = b.M_storage.size();
        // normalize
        uwide_type norm = uwide_type(BASE) / (b.M_storage.back() + 1);
        self_type an = a * self_type((wide_type)norm);
        self_type bn = b * self_type((wide_type)norm);
        an.M_storage.resize(n + 1, 0);

        self_type q{};
        q.M_storage.assign(n - m + 1, 0);

        for (size_type i{n - m}; i >= 0; --i)
        {
            uwide_type ai_m = uwide_type(an.M_storage[i + m]) * BASE
                            + uwide_type(an.M_storage[i + m - 1]);
            uwide_type qt = ai_m / uwide_type(bn.M_storage[m - 1]);
            if (qt >= BASE)
                qt = BASE - 1;

            // multiply bn by qt and subtract from an shifted at i
            uwide_type carry = 0, borrow = 0;
            for (size_t j = 0; j < m || carry; ++j)
            {
                uwide_type prod = qt * (j < m
                            ? uwide_type(bn.M_storage[j]) : 0) + carry;
                carry = prod / BASE;
                uwide_type sub = uwide_type(an.M_storage[i + j])
                                    - (prod % BASE) - borrow;
                if (wide_type(sub) < 0)
                {
                    sub += BASE;
                    borrow = 1;
                }
                else
                    borrow = 0;
                an.M_storage[i + j] = uint32_t(sub);
            }
            if (borrow)
            {
                // qt was too big; decrement qt and add bn back
                qt--;
                uwide_type carry2 = 0;
                for (size_t j = 0; j < m || carry2; ++j)
                {
                    uwide_type sum = uwide_type(an.M_storage[i + j])
                        + (j < m ? uwide_type(bn.M_storage[j]) : 0) + carry2;
                    an.M_storage[i + j] = uint32_t(sum % BASE);
                    carry2 = sum / BASE;
                }
            }
            q.M_storage[i] = uint32_t(qt);
        }
        q.M_trim();
        // remainder: an / norm
        self_type r{};
        r.M_storage.assign(an.M_storage.begin(), an.M_storage.begin() + m);
        // convert remainder back by dividing by norm
        // uwide_type carry = 0;
        r.M_storage.resize(an.M_storage.size()); // ensure enough size
        r.M_storage.assign(an.M_storage.begin(), an.M_storage.begin() + m);
        uwide_type remcarry = 0;
        for (int i = int(r.M_storage.size()) - 1; i >= 0; --i)
        {
            uwide_type cur = r.M_storage[i] + remcarry * BASE;
            r.M_storage[i] = uint32_t(cur / norm);
            remcarry = cur % norm;
        }
        r.M_trim();

        // fix signs
        q.M_positive = !(dividend.M_positive ^ divisor.M_positive);
        if (q.M_zero())
            q.M_positive = true;
        r.M_positive = dividend.M_positive;
        if (r.M_zero())
            r.M_positive = true;

        return std::make_pair(q, r);
    }

    /**
     * @brief Checks if the BigInteger is zero.
     * @return true if the value is zero, false otherwise.
     */
    bool M_zero() const
    {
        return M_storage.empty();
    }

    Storage M_storage{};
    bool M_positive{true};
};

// The storage policy defaults to std::vector<uint32_t>,
// and the numeric policy defaults to Decimal.
using bigint_t = BigInteger<std::vector<uint32_t>, Decimal>;

} // namespace torelis

using bigint = torelis::bigint_t;
