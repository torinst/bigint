/**
 * @file bigint
 * @brief A single-header C++ bigint implementation.
 * 
 * Copyright (c) 2025, Torelis.  All rights reserved.
 *
 * This file defines a bigint class that supports arbitrary-precision
 * integer arithmetic and comparison operations, exceeding the limits
 * of built-in integer types.
 */

#pragma once

/// This file uses C++11 features such as using type aliases and constexpr
/// variables and functions, so a C++11 compatible compiler is required.
#if __cplusplus < 201103L
# error "This header requires C++11 or higher"
#endif

#include <cstdarg>        // for va_list, va_start(), etc.
#include <cctype>
#include <cstdint>
#include <type_traits>    // for enable_if, etc.
#include <string>
#include <vector>
#include <algorithm>      // for reverse()
#include <iomanip>        // for setw(), setfill()
#include <sstream>        // for stringstream
#include <stdexcept>

namespace torelis
{

/**
 * @brief Throws an exception of type _Type with a formatted message.
 * 
 * @tparam _Type Exception type (must have constructor from std::string)
 * @param file Current file name (__FILE__)
 * @param line Current line number (__LINE__)
 * @param fmt printf-style format string
 * @param ... Format arguments
 */
template <typename _Type = std::logic_error>
[[noreturn]]
void __throw_fmt(const char* file, int line, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);

    // calculates message length
    va_list args_copy;
    va_copy(args_copy, args);
    int size = std::vsnprintf(nullptr, 0, fmt, args_copy);
    va_end(args_copy);
    if (size < 0)
    {
        va_end(args);
        throw std::runtime_error("failed to format exception message");
    }

    // full length
    int prefix = std::snprintf(nullptr, 0, "%s[at line %d]: ", file, line);
    int total = prefix + size;

    // Creates a buffer and write formatted string
    std::vector<char> buf(total + 1);
    int offset = std::snprintf(buf.data(),
        buf.size(), "%s[at line %d]: ", file, line);
    std::vsnprintf(buf.data() + offset, buf.size() - offset, fmt, args);
    va_end(args);

    throw _Type(buf.data());
}

#define throw_fmt(fmt, ...)          \
    __throw_fmt<>(__FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define throw_fmt_t(type, fmt, ...)  \
    __throw_fmt<type>(__FILE__, __LINE__, fmt, ##__VA_ARGS__)
// for convenient invocation
#define throw_domain_error_fmt(fmt, ...)          \
  __throw_fmt<std::domain_error>(__FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define throw_invalid_argument_fmt(fmt, ...)          \
  __throw_fmt<std::invalid_argument>(__FILE__, __LINE__, fmt, ##__VA_ARGS__)

/**
 * @brief This struct defines how digits of a bigint are represented and
 * managed internally. In other words, it specifies the numeric base(radix)
 * and related operations used for storing and manipulating large integers.
 * 
 * @note This struct provides basic numeric utilities. Concrete numeric
 * policies (e.g., Decimal, Binary) should derive from this struct. The
 * derived class must provide definitions for RADIX, BLOCK_SIZE, and BASE.
 */
struct Numeric
{
    typedef uint16_t radix_type;
    typedef uint64_t base_type;

    /// @brief Removes spaces from a numeric string.
    static std::string
    S_remove_space(const std::string& str)
    {
        std::string trimmed{};
        trimmed.reserve(str.size());
        for (const char c : str)
        {
            if (std::isspace(static_cast<uint8_t>(c)))
                continue;
            trimmed.push_back(c);
        }
        trimmed.shrink_to_fit();
        return trimmed;
    }

    /// @brief Trims leading zero from a numeric string.
    static std::string
    S_trim_leading_zero(const std::string& str)
    {
        auto pos = str.find_first_not_of('0');
        if (pos == std::string::npos)
            return std::string{};
        return str.substr(pos);
    }

    /**
     * @brief Parse the sign of a numeric string.
     * 
     * Sets @p positive to true if the @p str is positive, false if negative.
     */
    static std::string
    S_parse_sign(const std::string& str, bool& positive)
    {
        positive = true;
        if (str.empty())
            return {};
        auto last_sign = str.find_last_of("+-");
        if (last_sign != std::string::npos)
        {
            if (str[last_sign] == '-')
                positive = false;
            return str.substr(last_sign + 1);
        }
        return str;
    }

    /// @brief Removes spaces and leading zeros, and parses the sign.
    static std::string
    S_normalize(const std::string& str, bool& positive)
    {
        std::string normalized = S_remove_space(str);
        normalized = S_trim_leading_zero(normalized);
        normalized = S_parse_sign(normalized, positive);
        return normalized;
    }

    /**
     * @brief Apply a sign to a numeric string.
     * 
     * Prepends '-' if @p positive is false, otherwise do nothing.
     */
    static std::string
    S_apply_sign(const std::string& str, bool positive)
    {
        std::string signed_str{};
        if (!positive && !str.empty())
            signed_str.push_back('-');
        signed_str.append(str);
        return signed_str;
    }

    /// @brief Convert a numeric string from a given radix to decimal.
    static std::string
    S_from_radix(const std::string& str, radix_type radix)
    {
        std::string decimal{};
        for (const char c : str)
        {
            int digit = S_todigit(c);
            decimal = S_multiply_radix(decimal, radix, digit);
        }
        return decimal;
    }

    /// @brief Convert a numeric string from decimal to a given radix.
    static std::string
    S_to_radix(const std::string& str, radix_type radix)
    {
        std::string tmp{str};
        std::string radix_str{};
        while (!(tmp.empty()))
        {
            int remainder = 0;
            tmp = S_divide_radix(tmp, radix, remainder);
            radix_str.push_back(S_tochar(remainder));
        }
        std::reverse(radix_str.begin(), radix_str.end());
        return radix_str;
    }

    /// @brief Convert a numeric string from one radix to another.
    static std::string
    S_radix_convert(const std::string& str, radix_type from, radix_type to)
    {
        if (!S_check_radix(from))
            throw_invalid_argument_fmt("Radix 'from'"
                  " must in [2, 36], which is %hu", from);
        if (!S_check_radix(to))
            throw_invalid_argument_fmt("Radix 'to'"
                  " must in [2, 36], which is %hu", to);
        std::string tmp{S_from_radix(str, from)};
        return S_to_radix(tmp, to);
    }

    /// @brief The characters allowed in a number for a given radix.
    static std::string
    S_allowed_chars(radix_type radix)
    {
        if (!S_check_radix(radix))
            return {};
        std::string ret{};
        for (int i = 0; i < radix; ++i)
        {
            ret.push_back(S_tochar(i));
        }
        return ret;
    }

private:
    // Returns true if `radix >= l && radix <= r`, false otherwise.
    static bool
    S_check_radix(radix_type radix, radix_type l = 2, radix_type r = 36)
    {
        return radix >= l && radix <= r;
    }

    // Returns the index of a character in the sequence [0-9A-Z].
    static int S_todigit(char c)
    {
        uint8_t uc = static_cast<uint8_t>(c);
        if (std::isdigit(uc))
            return uc - '0';
        if (std::isalpha(uc))
        {
            uc = static_cast<uint8_t>(std::toupper(uc));
            return uc - 'A' + 10;
        }
        throw_invalid_argument_fmt("Must be"
              " 0-9, a-z, or A-Z (which is '%c')", c);
    }

    // Returns the character for an index in the sequence [0-9A-Z].
    static char S_tochar(int digit)
    {
        if (0 <= digit && digit <= 9)
            return static_cast<char>('0' + digit);
        if (10 <= digit && digit <= 35)
            return static_cast<char>('A' + (digit - 10));
        throw_invalid_argument_fmt("Must in [0, 35] (which is %d)", digit);
    }

    // Performs on a decimal string: ret = str * radix + digit
    static std::string
    S_multiply_radix(const std::string& str, radix_type radix, int digit)
    {
        std::string ret{str};
        int carry = digit;
        for (auto it = ret.rbegin(); it != ret.rend(); ++it)
        {
            int sum = (*it - '0') * radix + carry;
            *it = static_cast<char>((sum % 10) + '0');
            carry = sum / 10;
        }
        while (carry)
        {
            ret.insert(ret.begin(), static_cast<char>((carry % 10) + '0'));
            carry /= 10;
        }
        return ret;
    }

    // Performs division on a decimal string: str / radix
    static std::string
    S_divide_radix(const std::string& str, radix_type radix, int& remainder)
    {
        remainder = 0;
        std::string quotient{};
        for (const char c : str)
        {
            int x = remainder * 10 + (c - '0');
            quotient.push_back(static_cast<char>((x / radix) + '0'));
            remainder = x % radix;
        }
        return S_trim_leading_zero(quotient);
    }
};

/**
 * @brief block-wise storage with base (10 ^ 9)
 */
struct Decimal : public Numeric
{
    static constexpr radix_type RADIX = static_cast<radix_type>(10);
    static constexpr unsigned BLOCK_SIZE = static_cast<unsigned>(9);
    static constexpr base_type BASE = static_cast<base_type>(1000000000);
};

/**
 * @brief Wraps an STL-like container to expose required typedefs for bigint.
 * @tparam _Type The basic unit type for storing bigint, which determines how
 * the bigint is internally stored in blocks.
 * @tparam _Container Underlying container. Defaults to std::vector<_Type>
 */
template <typename _Type, typename _Container = std::vector<_Type>>
struct Storage
{
private:
    static_assert(std::is_same
        <typename _Container::value_type, _Type>::value,
      "_Container::value_type must be the same as _Type");

public:
    typedef _Container          container_type;
    typedef typename container_type::value_type  value_type;
    typedef typename container_type::size_type   size_type;
    typedef typename container_type::difference_type difference_type;

    // factory: creates an empty container
    static container_type make_empty()
    {
        return container_type();
    }
};

/**
 * @brief Bigint class template.
 * @tparam _Storage Storage policy, defaults to Storage<uint32_t>.
 * @tparam _Numeric Numeric policy, defaults to Decimal.
 * @tparam _Enable SFINAE helper, defaults to void.
 */
template <typename _Storage = Storage<uint32_t>,
  typename _Numeric = Decimal, typename _Enable = void>
class bigint;   // primary declaration

/**
 * @brief Type trait to detect whether a container type
 * has a nested `value_type`.
 * @tparam _T Container type to check.
 */
template <typename _T>
struct has_value_type
{
private:
    template <typename _U>
    static typename _U::value_type test(_U*);

    template <typename>
    static void test(...);

public:
    enum { value = !std::is_same<void, decltype(test((_T*)0))>::value };
};

/**
 * @brief Trait that is true if _Derived is a strict subclass of _Base.
 * @tparam _Base Base class type.
 * @tparam _Derived Derived class type.
 * @note A strict subclass is defined as: _Derived inherits from _Base
 * but is not the same type.
 */
template <typename _Base, typename _Derived>
struct is_strict_base_of
  : std::integral_constant
       <bool, std::is_base_of<_Base, _Derived>::value
    && !std::is_same<_Base, _Derived>::value>
{ };

// Specialization when passed Storage-like type (has nested types)
template <typename _Storage, typename _Numeric>
class bigint<_Storage, _Numeric, typename std::enable_if
        <has_value_type<_Storage>::value
      && is_strict_base_of<Numeric, _Numeric>::value>::type>
{
private:
    // types from storage
    typedef _Storage                            storage_type;
    typedef typename storage_type::container_type container_type;
    typedef typename storage_type::value_type   value_type;
    typedef typename storage_type::size_type    size_type;
    typedef typename storage_type::difference_type difference_type;

    // numeric types
    typedef _Numeric                            numeric_type;
    typedef typename numeric_type::base_type    base_type;
    typedef typename numeric_type::radix_type   radix_type;

    // extra utility types
    typedef int64_t                         wide_type;
    typedef uint64_t                        uwide_type;

    static_assert(std::is_integral<value_type>::value,
                     "Storage block type must be integral");

protected:
    static constexpr radix_type RADIX = numeric_type::RADIX;
    static constexpr unsigned SIZE = numeric_type::BLOCK_SIZE;
    static constexpr base_type BASE = numeric_type::BASE;

public:
    // construct/copy/destroy
    /**
     * @brief Creates a bigint without providing a value.
     * @note If no value is provided, a bigint defaults to 0.
     */
    bigint() = default;

    /**
     * @brief Creates a bigint from a 64-bit integer.
     * @param integer A 64-bit integer used to create bigint.
     */
    bigint(int64_t integer)
    {
        (void)(this->M_assign(integer));
    }

    /**
     * @brief Creates a bigint from a string representation.
     * @param str Numeric string to create the bigint.
     * @param radix Numeric radix of the string, defaults to RADIX.
     * 
     * If the numeric string's radix differs from RADIX, use this
     * constructor to explicitly specify the radix; otherwise, the
     * result may be incorrect.
     */
    bigint(const std::string& str, radix_type radix = RADIX)
    {
        (void)(this->M_assign(str, radix));
    }

    /**
     * @brief Creates a bigint from a C-string.
     * @param cstr Numeric C-string to create the bigint.
     * @param radix Numeric radix of the string, defaults to RADIX.
     * 
     * C-string version of
     * `bigint(const std::string& str, radix_type radix = RADIX)`
     */
    template <typename _Cstr, typename = typename std::enable_if
             <std::is_same<_Cstr, const char*>::value>::type>
    bigint(_Cstr cstr, radix_type radix = RADIX)
    : bigint(std::string(cstr), radix)
    { }

    /// Copy constructor
    bigint(const bigint&) = default;
    /// Move constructor
    bigint(bigint&&) noexcept = default;
    /// Destructor
    ~bigint() = default;

    /**
     * @brief Bigint integer assignment operator.
     * @param integer A 64-bit integer used to assign current bigint.
     */
    bigint& operator=(int64_t integer)
    {
        return this->M_assign(integer);
    }

    /**
     * @brief Bigint string assignment operator.
     * @param str A string used to assign current bigint.
     */
    bigint& operator=(const std::string& str)
    {
        return this->M_assign(str, RADIX);
    }

    /**
     * @brief Bigint C-string assignment operator.
     * @param str A C-string used to assign current bigint.
     */
    template <typename _Cstr, typename = typename std::enable_if
             <std::is_same<_Cstr, const char*>::value>::type>
    bigint& operator=(_Cstr cstr)
    {
        return this->operator=(std::string(cstr));
    }

    /// Bigint assignment operator.
    bigint& operator=(const bigint&) = default;
    /// Bigint move assignment operator.
    bigint& operator=(bigint&&) noexcept = default;

    /// the four basic arithmetic operations
    /// addition
    /**
     * @brief Returns the sum of two bigints.
     * @param lhs The left-hand side bigint.
     * @param rhs The right-hand side bigint.
     * @return A new bigint representing the sum.
     */
    friend bigint operator+(const bigint& lhs, const bigint& rhs)
    {
        if (lhs.M_positive == rhs.M_positive)
        {
            bigint r = lhs;
            r.M_add_abs(rhs);
            return r;
        }
        int cmp = lhs.M_compare_abs(rhs);
        if (cmp == 0)
            return static_cast<bigint>(0);
        if (cmp > 0)
        {
            bigint r = lhs;
            r.M_subtract_abs(rhs);
            return r;
        }
        bigint r = rhs;
        r.M_subtract_abs(lhs);
        return r;
    }

    /**
     * @brief Adds another bigint to this one.
     * @param integer The bigint to add.
     * @return Reference to this bigint after addition.
     */
    bigint& operator+=(const bigint& integer)
    {
        *this = *this + integer;
        return *this;
    }

    /// subtraction
    /**
     * @brief Returns the difference between two bigints.
     * @param lhs The left-hand side bigint.
     * @param rhs The right-hand side bigint.
     * @return A new bigint representing the difference.
     */
    friend bigint
    operator-(const bigint& lhs, const bigint& rhs)
    {
        if (lhs.M_positive != rhs.M_positive)
        {
            bigint r = lhs;
            r.M_add_abs(rhs);
            return r;
        }
        int cmp = lhs.M_compare_abs(rhs);
        if (cmp == 0)
            return static_cast<bigint>(0);
        if (cmp > 0)
        {
            bigint r = lhs;
            r.M_subtract_abs(rhs);
            return r;
        }
        bigint r = rhs;
        r.M_subtract_abs(lhs);
        r.M_positive = !r.M_positive;
        return r;
    }

    /**
     * @brief Subtracts another bigint from this one.
     * @param integer The bigint to subtract.
     * @return Reference to this bigint after subtraction.
     */
    bigint& operator-=(const bigint& integer)
    {
        *this = *this - integer;
        return *this;
    }

    /// multiplication
    /**
     * @brief Returns the product of two bigints.
     * @param lhs The left-hand side bigint.
     * @param rhs The right-hand side bigint.
     * @return A new bigint representing the product.
     */
    friend bigint
    operator*(const bigint& lhs, const bigint& rhs)
    {
        bigint r = S_multiply_abs(lhs, rhs);
        r.M_positive = !(lhs.M_positive ^ rhs.M_positive);
        if (r.M_zero())
            r.M_positive = true;
        return r;
    }

    /**
     * @brief Multiplies this bigint by another.
     * @param integer The bigint to multiply with.
     * @return Reference to this bigint after multiplication.
     */
    bigint& operator*=(const bigint& integer)
    {
        *this = *this * integer;
        return *this;
    }

    /// division
    /**
     * @brief Returns the quotient of two bigints.
     * @param lhs The dividend bigint.
     * @param rhs The divisor bigint.
     * @return A new bigint representing the quotient.
     */
    friend bigint
    operator/(const bigint& lhs, const bigint& rhs)
    {
        return S_divmod(lhs, rhs).first;
    }

    /**
     * @brief Divides this bigint by another.
     * @param integer The bigint to divide by.
     * @return Reference to this bigint after division.
     */
    bigint& operator/=(const bigint& integer)
    {
        *this = *this / integer;
        return *this;
    }

    /// modulo
    /**
     * @brief Returns the remainder of division between two bigints.
     * @param lhs The dividend bigint.
     * @param rhs The divisor bigint.
     * @return A new bigint representing the remainder.
     */
    friend bigint
    operator%(const bigint& lhs, const bigint& rhs)
    {
        return S_divmod(lhs, rhs).second;
    }

    /**
     * @brief Computes the remainder of this bigint divided by another.
     * @param integer The bigint to divide by.
     * @return Reference to this bigint after modulo operation.
     */
    bigint& operator%=(const bigint& integer)
    {
        *this = *this % integer;
        return *this;
    }

    /// increment and decrement operators
    /**
     * @brief Pre-increments this bigint by 1.
     * @return Reference to this bigint after increment.
     */
    bigint& operator++()
    {
        *this += static_cast<bigint>(1);
        return *this;
    }

    /**
     * @brief Post-increments this bigint by 1.
     * @param int Dummy parameter to distinguish post-increment.
     * @return A copy of the bigint before increment.
     */
    bigint operator++(int)
    {
        bigint r = *this;
        *this += static_cast<bigint>(1);
        return r;
    }

    /**
     * @brief Pre-decrements this bigint by 1.
     * @return Reference to this bigint after decrement.
     */
    bigint& operator--()
    {
        *this -= static_cast<bigint>(1);
        return *this;
    }

    /**
     * @brief Post-decrements this bigint by 1.
     * @param int Dummy parameter to distinguish post-decrement.
     * @return A copy of the bigint before decrement.
     */
    bigint operator--(int)
    {
        bigint r = *this;
        *this -= static_cast<bigint>(1);
        return r;
    }

    /// comparisons
    /**
     * @brief Checks if lhs is less than rhs.
     * @return true if lhs < rhs, otherwise false.
     */
    friend bool
    operator<(const bigint& lhs, const bigint& rhs)
    {
        if (lhs.M_positive != rhs.M_positive)
            return rhs.M_positive;
        int cmp = lhs.M_compare_abs(rhs);
        return (lhs.M_positive ? cmp < 0 : cmp > 0);
    }

    /**
     * @brief Checks if lhs is less than or equal to rhs.
     * @return true if lhs <= rhs, otherwise false.
     */
    friend bool
    operator<=(const bigint& lhs, const bigint& rhs)
    {
        return !(rhs < lhs);
    }

    /**
     * @brief Checks if lhs is greater than rhs.
     * @return true if lhs > rhs, otherwise false.
     */
    friend bool
    operator>(const bigint& lhs, const bigint& rhs)
    {
        return rhs < lhs;
    }

    /**
     * @brief Checks if lhs is greater than or equal to rhs.
     * @return true if lhs >= rhs, otherwise false.
     */
    friend bool
    operator>=(const bigint& lhs, const bigint& rhs)
    {
        return !(lhs < rhs);
    }

    /**
     * @brief Checks if lhs is equal to rhs.
     * @return true if lhs == rhs, otherwise false.
     */
    friend bool
    operator==(const bigint& lhs, const bigint& rhs)
    {
        return (lhs.M_positive == rhs.M_positive
             && lhs.M_storage == rhs.M_storage);
    }

    /**
     * @brief Checks if lhs is not equal to rhs.
     * @return true if lhs != rhs, otherwise false.
     */
    friend bool
    operator!=(const bigint& lhs, const bigint& rhs)
    {
        return !(lhs == rhs);
    }

    /// stream IO
    /**
     * @brief Reads a bigint from a stream.
     */
    friend std::istream&
    operator>>(std::istream& is, bigint& integer)
    {
        std::string str{};
        if (!(is >> str))
            return is;
        str = numeric_type::S_normalize(str, integer.M_positive);
        integer.M_assign(str);
        return is;
    }

    /**
     * @brief Outputs the bigint to a stream.
     */
    friend std::ostream&
    operator<<(std::ostream& os, const bigint& integer)
    {
        os << integer.to_string();
        return os;
    }

    /// other public methods
    /**
     * @brief Converts to true if the bigint
     * is non-zero, otherwise false.
     */
    explicit operator bool() const noexcept
    {
        return !M_zero();
    }

    /**
     * @brief Returns the negation of this bigint.
     * @return A new bigint with the opposite sign.
     */
    bigint operator-() const
    {
        bigint r = *this;
        if (r.M_zero())
            r.M_positive = !r.M_positive;
        return r;
    }

    /**
     * @brief Returns the absolute value of this bigint.
     * @return A new bigint representing the absolute value.
     */
    bigint abs() const
    {
        bigint r = *this;
        r.M_positive = true;
        return r;
    }

    /**
     * @brief Returns the sign of the bigint.
     * @return 1 if positive, -1 if negative, 0 if zero.
     */
    int sign() const
    {
        if (M_zero())
            return 0;
        return (M_positive ? 1 : -1);
    }

    /**
     * @brief Converts the bigint to its string representation.
     * @return A string representing the value of the bigint.
     */
    std::string to_string() const
    {
        if (M_zero())
            return "0";
        std::stringstream ss{};
        if (!M_positive)
            ss << '-';
        ss << (M_storage.empty() ? 0 : M_storage.back());
        for (auto it = M_storage.rbegin() + 1; it != M_storage.rend(); ++it)
        {
            ss << std::setw(SIZE) << std::setfill('0') << (*it);
        }
        return ss.str();
    }

private:
    /// Removes unnecessary leading zeros from the bigint.
    void M_trim() noexcept
    {
        while (!M_storage.empty() && M_storage.back() == 0)
            M_storage.pop_back();
        if (M_storage.empty()) // zero is positive
            M_positive = true;
    }

    /// Resets the bigint to zero.
    /// Clears all internal data and sets the value to 0.
    void M_reset() noexcept
    {
        M_storage.clear();
        M_positive = true;
    }

    /// Assigns the value of a 64-bit integer to this bigint.
    bigint& M_assign(int64_t integer)
    {
        M_reset();
        if (integer < 0)
        {
            M_positive = false;
            integer = -integer;
        }
        while (integer)
        {
            value_type x = static_cast<value_type>(integer % BASE);
            M_storage.push_back(x);
            integer /= BASE;
        }
        return *this;
    }

    /// Assigns the value of a string to this bigint.
    bigint& M_assign(const std::string& str, radix_type radix)
    {
        M_reset();

        std::string normalized = numeric_type::S_normalize(str, M_positive);
        if (radix != RADIX)
        {
            normalized = numeric_type
              ::S_radix_convert(normalized, radix, RADIX);
        }
        std::string::size_type n = normalized.size();
        using diff_t = std::string::difference_type;
        for (diff_t i{static_cast<diff_t>(n) - 1};
             i >= 0; i -= static_cast<diff_t>(SIZE))
        {
            value_type x = 0;
            // size_t l = std::max(pos, i - SIZE + 1);
            diff_t l = std::max((diff_t)0, i - (diff_t)SIZE + 1);
            std::string allowed_chars = numeric_type::S_allowed_chars(RADIX);
            for (diff_t j = l; j <= i; ++j)
            {
                char c = normalized.at(j);
                if (allowed_chars.find(c) == std::string::npos)
                    throw_invalid_argument_fmt("Allowed characters "
                          "are %s (case-insensitive), "
                          "which is %c",
                        allowed_chars.c_str(), c);
                x = x * RADIX + (c - '0');
            }
            M_storage.push_back(x);
        }
        M_trim();
        return *this;
    }

    /// Compares the absolute value of this bigint with another.
    /// @return A positive value if |this| > |other|, zero if
    /// |this| == |other|, or a negative value if |this| < |other|.
    int M_compare_abs(const bigint& other) const
    {
        if (M_storage.size() != other.M_storage.size())
            return (M_storage.size() < other.M_storage.size() ? -1 : 1);
        // for (size_type i = M_storage.size() - 1; i >= 0; --i)
        for (difference_type i = M_storage.size() - 1; i >= 0; --i)
        {
            if (M_storage[i] != other.M_storage[i])
                return (M_storage[i] < other.M_storage[i] ? -1 : 1);
        }
        return 0;
    }

    /// Adds the absolute value of another bigint to this one.
    void M_add_abs(const bigint& other)
    {
        uwide_type carry{0};
        size_type n = std::max(M_storage.size(), other.M_storage.size());
        if (M_storage.size() < n)
            M_storage.resize(n, 0);
        for (size_type i{0}; i < n; ++i)
        {
            uwide_type sum = carry + M_storage[i]
                + (i < other.M_storage.size() ? other.M_storage[i] : 0);
            M_storage[i] = static_cast<value_type>(sum % BASE);
            carry = sum / BASE;
        }
        if (carry)
            M_storage.push_back(static_cast<value_type>(carry));
    }

    /// Subtracts the absolute value of another bigint from this one.
    void M_subtract_abs(const bigint& other)
    {
        wide_type carry{0};
        for (size_type i{0}; i < other.M_storage.size() || carry; ++i)
        {
            wide_type curr = (wide_type)M_storage[i]
                - (i < other.M_storage.size() ? other.M_storage[i] : 0)
                - carry;
            if (curr < 0)
            {
                curr += BASE;
                carry = 1;
            }
            else
                carry = 0;
            M_storage[i] = static_cast<value_type>(curr);
        }
        M_trim();
    }

    /// Returns the product of the absolute values of two bigints.
    static bigint
    S_multiply_abs(const bigint& lhs, const bigint& rhs)
    {
        if (lhs.M_zero() || rhs.M_zero())
            return bigint(0);
        bigint product{};
        product.M_storage.assign(lhs.M_storage.size() + rhs.M_storage.size(), 0);
        for (size_type i{0}; i < lhs.M_storage.size(); ++i)
        {
            uwide_type carry{0};
            uwide_type xi = static_cast<uwide_type>(lhs.M_storage[i]);
            for (size_type j{0}; j < rhs.M_storage.size() || carry; ++j)
            {
                uwide_type curr = carry + product.M_storage[i + j]
                    + xi * (j < rhs.M_storage.size()
                    ? uwide_type(rhs.M_storage[j]) : 0);
                product.M_storage[i + j] = static_cast<value_type>(curr % BASE);
                carry = curr / BASE;
            }
        }
        product.M_trim();
        return product;
    }

    /// Divides two bigints and returns both quotient and remainder.
    /// @return A pair containing {quotient, remainder}.
    static std::pair<bigint, bigint>
    S_divmod(const bigint& dividend, const bigint& divisor)
    {
        if (divisor.M_zero())
            throw_domain_error_fmt("division by zero");
        bigint a = dividend.abs();
        bigint b = divisor.abs();
        if (a.M_compare_abs(b) < 0)
        {
            return {bigint(0), dividend};
        }
        size_t n = a.M_storage.size();
        size_t m = b.M_storage.size();
        // normalize
        uwide_type norm = uwide_type(BASE) / (b.M_storage.back() + 1);
        bigint an = a * bigint((wide_type)norm);
        bigint bn = b * bigint((wide_type)norm);
        an.M_storage.resize(n + 1, 0);

        bigint q{};
        q.M_storage.assign(n - m + 1, 0);

        using diff_t = difference_type;
        for (diff_t i = static_cast<diff_t>(n - m); i >= 0; --i)
        {
            uwide_type ai_m = uwide_type(an.M_storage[i + m]) * BASE
                            + uwide_type(an.M_storage[i + m - 1]);
            uwide_type qt = ai_m / uwide_type(bn.M_storage[m - 1]);
            if (qt >= BASE)
                qt = BASE - 1;

            // multiply bn by qt and subtract from an shifted at i
            uwide_type carry = 0, borrow = 0;
            for (diff_t j = 0; j < m || carry; ++j)
            {
                uwide_type prod = qt * (j < m
                            ? uwide_type(bn.M_storage[j]) : 0) + carry;
                carry = prod / BASE;
                uwide_type sub = uwide_type(an.M_storage[i + j])
                                    - (prod % BASE) - borrow;
                if (wide_type(sub) < 0)
                {
                    sub += BASE;
                    borrow = 1;
                }
                else
                    borrow = 0;
                an.M_storage[i + j] = uint32_t(sub);
            }
            if (borrow)
            {
                // qt was too big; decrement qt and add bn back
                qt--;
                uwide_type carry2 = 0;
                for (size_t j = 0; j < m || carry2; ++j)
                {
                    uwide_type sum = uwide_type(an.M_storage[i + j])
                        + (j < m ? uwide_type(bn.M_storage[j]) : 0) + carry2;
                    an.M_storage[i + j] = uint32_t(sum % BASE);
                    carry2 = sum / BASE;
                }
            }
            q.M_storage[i] = uint32_t(qt);
        }
        q.M_trim();
        // remainder: an / norm
        bigint r{};
        r.M_storage.assign(an.M_storage.begin(), an.M_storage.begin() + m);
        // convert remainder back by dividing by norm
        // uwide_type carry = 0;
        r.M_storage.resize(an.M_storage.size()); // ensure enough size
        r.M_storage.assign(an.M_storage.begin(), an.M_storage.begin() + m);
        uwide_type remcarry = 0;
        for (auto it = r.M_storage.rbegin(); it != r.M_storage.rend(); ++it)
        {
            uwide_type cur = static_cast<uwide_type>(*it) + remcarry * BASE;
            *it = static_cast<value_type>(cur / norm);
            remcarry = cur % norm;
        }
        r.M_trim();

        // fix signs
        q.M_positive = !(dividend.M_positive ^ divisor.M_positive);
        if (q.M_zero())
            q.M_positive = true;
        r.M_positive = dividend.M_positive;
        if (r.M_zero())
            r.M_positive = true;

        return std::make_pair(q, r);
    }

    /// Checks if the bigint is zero.
    /// @return true if the bigint is zero, false otherwise.
    bool M_zero() const
    {
        return M_storage.empty();
    }

private:
    container_type M_storage{};
    bool M_positive{true};
};

// default: 32-bit block (fits BASE under 2^32), container std::vector
typedef Storage<uint32_t, std::vector<uint32_t>> DefaultStorage;
using bigint_t = bigint<DefaultStorage, Decimal>;

} // namespace torelis

// alias in global namespace for convenience
using bigint = torelis::bigint_t;
