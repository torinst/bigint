/**
 * @file bigint
 * @brief A single-header C++ BigInteger implementation.
 * 
 * Copyright (c) 2025, Torelis.  All rights reserved.
 *
 * This file defines a BigInteger class that supports arbitrary-precision
 * integer arithmetic and comparison operations, exceeding the limits of
 * built-in integer types.
 *
 * Arbitrary-precision integer representation.
 * Basic arithmetic operations: addition, subtraction, multiplication
 * and division.
 * Comparison operators (==, !=, <, <=, >, >=).
 * Policy-based design for base/radix and storage (extensible).
 * Header-only, no external dependencies.
 */

#pragma once

/// This file uses C++11 features such as using type aliases and constexpr
/// variables and functions, so a C++11 compatible compiler is required.
/// If compiling with a version earlier than C++11, you will need to replace
/// these features with equivalent C++98/03 code and remove the following
/// conditional compilation.
#if __cplusplus < 201103L
  #error "This project requires C++11 or higher"
#endif

#include <bits/stdint-uintn.h>
#include <vector>
#include <sstream>  // stringstream
#include <iomanip>  // setw(), setfill()

namespace torelis
{
/**
 * @brief Base Policy for BigInteger.
 *
 * The Base Policy defines how digits of a BigInteger are represented
 * and managed internally. In other words, it specifies the numeric base
 * (radix) and related operations used for storing and manipulating
 * large integers.
 * 
 * To add a new base policy, implement the required interfaces
 * (digit type, base constant, helper functions).
 * Plug it into BigInteger via templates.
 */
// block-wise storage with base (10 ^ 9)
struct Base10e9 // RADIX = 10 ^ DIGITS_PER_BLOCK
{
    using base_type = uint32_t;
    static constexpr base_type RADIX = 1000000000U;
    static constexpr unsigned DIGITS_PER_BLOCK = 9U;
};

// block-wise storage with base (2 ^ 32)
struct Base2e32 // RADIX = 2 ^ DIGITS_PER_BLOCK
{
    using base_type = uint64_t;
    static constexpr base_type RADIX = 0x100000000UL;
    static constexpr unsigned DIGITS_PER_BLOCK = 32U;
};

/**
 * @brief Storage Policy for BigInteger.
 *
 * @tparam T The type of elements stored in the vector.
 * This can be any copyable or movable type that the vector will hold.
 * 
 * The Storage Policy defines how the sequence of digits (blocks)
 * of a BigInteger is stored in memory. It abstracts away the underlying
 * container and memory management, allowing flexibility in performance,
 * memory usage, and custom allocation strategies.
 *
 * Separates the storage mechanism from arithmetic logic.
 * Allows swapping different containers (e.g., std::vector, std::deque,
 * custom allocator).
 * Supports dynamic resizing, insertion, and removal of digit blocks.
 * 
 * @note If an STL container is used as the storage policy, it can
 * be passed directly to the BigInteger template class via the first
 * template parameter. Only when managing the storage policy manually
 * is it necessary to implement a Storage class (or struct).
 */
template <typename T>
struct Storage
{
};

/**
 * @brief Arbitrary-precision integer class using policy-based design.
 *
 * @tparam StoragePolicy  Defines how the sequence of digit blocks is
 * stored in memory.
 * eg., dynamic array(std::vector), fixed-size array, or custom allocator.
 * @tparam BasePolicy  Defines the numeric base (radix) and digit
 * representation.
 * eg., Base10e9 (blocks of 10^9), Base2^32 (binary blocks).
 *
 * @details
 * The BigInteger class provides arithmetic and comparison operations for
 * integers beyond the limits of built-in types. It separates the storage
 * mechanism and digit representation from arithmetic logic using policies,
 * making it modular and adaptable.
 * 
 * @note When providing StoragePolicy and BasePolicy, please
 * ensure that for any number x, with BASE = BasePolicy::RADIX
 * and TYPE = StoragePolicy::value_type, it holds that
 * (x % BASE) <= std::numeric_limits<TYPE>::max().
 */
template <class StoragePolicy, class BasePolicy>
class BigInteger
{
private:
    using base_type = typename BasePolicy::base_type;
    using value_type = typename StoragePolicy::value_type;
    using size_type = typename StoragePolicy::size_type;
    using wide_type = int64_t;
    using uwide_type = uint64_t;
    static constexpr base_type BASE = BasePolicy::RADIX;
    static constexpr unsigned SIZE = BasePolicy::DIGITS_PER_BLOCK;

    using self_type = BigInteger<StoragePolicy, BasePolicy>;
    using self_reference = self_type&;
    using const_self_reference = const self_type&;

public:

private:
    void M_trim() noexcept
    {
        while (!M_storage.empty() && M_storage.back() == 0)
            M_storage.pop_back();
        if (M_storage.empty()) // zero is positive
            M_positive = true;
    }

    void M_reset() noexcept
    {
        M_storage.clear();
        M_positive = true;
    }

    self_reference M_from_string(const std::string& str)
    {
        M_reset();
        size_t pos{0}, n = str.size();
        for (; pos < n && isspace((unsigned char)str[pos]); ++pos);
        if (pos < n && (str[pos] == '+' || str[pos] == '-'))
        {
            M_positive = (str[pos] == '+');
            ++pos;
        }
        for (ptrdiff_t i{static_cast<ptrdiff_t>(n) - 1};
             i >= static_cast<ptrdiff_t>(pos);
             i -= static_cast<ptrdiff_t>(SIZE))
        {
            value_type x = 0;
            // size_t l = std::max(pos, i - SIZE + 1);
            ptrdiff_t l = std::max((ptrdiff_t)pos, i - (ptrdiff_t)SIZE + 1);
            for (ptrdiff_t j = l; j <= i; ++j)
            {
                if (!isdigit((unsigned char)str[j]))
                {
                    throw std::invalid_argument("Invalid digit");
                }
                x = x * 10 + (str[j] - '0');
            }
            M_storage.push_back(x);
        }
        M_trim();
        return *this;
    }

    int M_compare_abs(const_self_reference other) const
    {
        if (M_storage.size() != other.M_storage.size())
            return (M_storage.size() < other.M_storage.size() ? -1 : 1);
        for (size_type i = M_storage.size() - 1; i >= 0; --i)
        {
            if (M_storage[i] != other.M_storage[i])
                return (M_storage[i] < other.M_storage[i] ? -1 : 1);
        }
        return 0;
    }

    void M_add_abs(const_self_reference other)
    {
        uwide_type carry{0};
        size_type n = std::max(M_storage.size(), other.M_storage.size());
        if (M_storage.size() < n)
            M_storage.resize(n, 0);
        for (size_type i{0}; i < n; ++i)
        {
            uwide_type sum = carry + M_storage[i]
                + (i < other.M_storage.size() ? other.M_storage[i] : 0);
            M_storage[i] = static_cast<value_type>(sum % BASE);
            carry = sum / BASE;
        }
        if (carry)
            M_storage.push_back(static_cast<value_type>(carry));
    }

    void M_subtract_abs(const_self_reference other)
    {
        wide_type carry{0};
        for (size_type i{0}; i < other.M_storage.size() || carry; ++i)
        {
            wide_type curr = (wide_type)M_storage[i]
                - (i < other.M_storage.size() ? other.M_storage[i] : 0)
                - carry;
            if (curr < 0)
            {
                curr += BASE;
                carry = 1;
            }
            else
                carry = 0;
            M_storage[i] = static_cast<value_type>(curr);
        }
        M_trim();
    }

    static self_type
    S_multiply_abs(const_self_reference lhs, const_self_reference rhs)
    {
        if (lhs.M_zero() || rhs.M_zero())
            return self_type(0);
        self_type ret{};
        ret.M_storage.assign(lhs.M_storage.size() + rhs.M_storage.size(), 0);
        for (size_type i{0}; i < lhs.M_storage.size(); ++i)
        {
            uwide_type carry{0};
            uwide_type xi = static_cast<uwide_type>(lhs.M_storage[i]);
            for (size_type j{0}; j < rhs.M_storage.size() || carry; ++j)
            {
                uwide_type curr = carry + ret.M_storage[i + j]
                    + xi * (j < rhs.M_storage.size()
                    ? uwide_type(rhs.M_storage[j]) : 0);
                ret.M_storage[i + j] = static_cast<value_type>(curr % BASE);
                carry = curr / BASE;
            }
        }
        ret.M_trim();
        return ret;
    }

    static std::pair<self_type, self_type>
    S_divmod(const_self_reference dividend, const_self_reference divisor)
    {
        if (divisor.M_zero())
            throw std::runtime_error("Division by zero");
        self_type a = dividend.abs();
        self_type b = divisor.abs();
        if (a.M_compare_abs(b) < 0)
        {
            return {self_type(0), dividend};
        }
        size_t n = a.M_storage.size();
        size_t m = b.M_storage.size();
        // normalize
        uwide_type norm = uwide_type(BASE) / (b.M_storage.back() + 1);
        self_type an = a * self_type((wide_type)norm);
        self_type bn = b * self_type((wide_type)norm);
        an.M_storage.resize(n + 1, 0);

        self_type q{};
        q.M_storage.assign(n - m + 1, 0);

        for (size_type i{n - m}; i >= 0; --i)
        {
            uwide_type ai_m = uwide_type(an.M_storage[i + m]) * BASE
                            + uwide_type(an.M_storage[i + m - 1]);
            uwide_type qt = ai_m / uwide_type(bn.M_storage[m - 1]);
            if (qt >= BASE)
                qt = BASE - 1;

            // multiply bn by qt and subtract from an shifted at i
            uwide_type carry = 0, borrow = 0;
            for (size_t j = 0; j < m || carry; ++j)
            {
                uwide_type prod = qt * (j < m
                            ? uwide_type(bn.M_storage[j]) : 0) + carry;
                carry = prod / BASE;
                uwide_type sub = uwide_type(an.M_storage[i + j])
                                    - (prod % BASE) - borrow;
                if (wide_type(sub) < 0)
                {
                    sub += BASE;
                    borrow = 1;
                }
                else
                    borrow = 0;
                an.M_storage[i + j] = uint32_t(sub);
            }
            if (borrow)
            {
                // qt was too big; decrement qt and add bn back
                qt--;
                uwide_type carry2 = 0;
                for (size_t j = 0; j < m || carry2; ++j)
                {
                    uwide_type sum = uwide_type(an.M_storage[i + j])
                        + (j < m ? uwide_type(bn.M_storage[j]) : 0) + carry2;
                    an.M_storage[i + j] = uint32_t(sum % BASE);
                    carry2 = sum / BASE;
                }
            }
            q.M_storage[i] = uint32_t(qt);
        }
        q.M_trim();
        // remainder: an / norm
        self_type r{};
        r.M_storage.assign(an.M_storage.begin(), an.M_storage.begin() + m);
        // convert remainder back by dividing by norm
        // uwide_type carry = 0;
        r.M_storage.resize(an.M_storage.size()); // ensure enough size
        r.M_storage.assign(an.M_storage.begin(), an.M_storage.begin() + m);
        uwide_type remcarry = 0;
        for (int i = int(r.M_storage.size()) - 1; i >= 0; --i)
        {
            uwide_type cur = r.M_storage[i] + remcarry * BASE;
            r.M_storage[i] = uint32_t(cur / norm);
            remcarry = cur % norm;
        }
        r.M_trim();

        // fix signs
        q.M_positive = dividend.M_positive ^ divisor.M_positive;
        if (q.M_zero())
            q.M_positive = true;
        r.M_positive = dividend.M_positive;
        if (r.M_zero())
            r.M_positive = true;

        return std::make_pair(q, r);
    }

    bool M_zero() const
    {
        return M_storage.empty();
    }

    StoragePolicy M_storage{};
    bool M_positive{true};
};

// The storage policy defaults to std::vector<uint32_t>,
// and the base policy defaults to Base10e9.
using bigint_t = BigInteger<std::vector<uint32_t>, Base10e9>;

} // namespace torelis

using bigint = torelis::bigint_t;
