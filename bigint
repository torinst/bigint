/**
 * @file bigint
 * @brief A single-header C++ BigInteger implementation.
 * 
 * Copyright (c) 2025, torelis.  All rights reserved.
 *
 * This file defines a BigInteger class that supports arbitrary-precision
 * integer arithmetic and comparison operations, exceeding the limits of
 * built-in integer types.
 *
 * Arbitrary-precision integer representation.
 * Basic arithmetic operations: addition, subtraction, multiplication
 * and division.
 * Comparison operators (==, !=, <, <=, >, >=).
 * Policy-based design for base/radix and storage (extensible).
 * Header-only, no external dependencies.
 */

#pragma once

/// This file uses C++11 features such as using type aliases and constexpr
/// variables and functions, so a C++11 compatible compiler is required.
/// If compiling with a version earlier than C++11, you will need to replace
/// these features with equivalent C++98/03 code and remove the following
/// conditional compilation.
#if __cplusplus < 201103L
  #error "This project requires C++11 or higher"
#endif

#include <bits/stdint-uintn.h>
#include <vector>

namespace torelis
{
/**
 * @brief Base Policy for BigInteger.
 *
 * The Base Policy defines how digits of a BigInteger are represented
 * and managed internally. In other words, it specifies the numeric base
 * (radix) and related operations used for storing and manipulating
 * large integers.
 * 
 * To add a new base policy, implement the required interfaces
 * (digit type, base constant, helper functions).
 * Plug it into BigInteger via templates.
 */
// block-wise storage with base (10 ^ 9)
struct Base10e9
{
    using uint = uint32_t;
    static constexpr uint BASE = 1000000000;
    static constexpr int WIDTH = 9;
};

// block-wise storage with base (2 ^ 32)
struct Base2e32
{
    using uint = uint64_t;
    static constexpr uint BASE = 0xffffffffULL + 1ULL;
    static constexpr int WIDTH = 32;
};

/**
 * @brief Storage Policy for BigInteger.
 *
 * @tparam T The type of elements stored in the vector.
 * This can be any copyable or movable type that the vector will hold.
 * 
 * The Storage Policy defines how the sequence of digits (blocks)
 * of a BigInteger is stored in memory. It abstracts away the underlying
 * container and memory management, allowing flexibility in performance,
 * memory usage, and custom allocation strategies.
 *
 * Separates the storage mechanism from arithmetic logic.
 * Allows swapping different containers (e.g., std::vector, std::deque,
 * custom allocator).
 * Supports dynamic resizing, insertion, and removal of digit blocks.
 */
template <typename T>
struct VectorStorage
{
private:
    using container_type = std::vector<T>;
    using value_type = typename container_type::value_type;
    using iterator = typename container_type::iterator;
    using const_iterator = typename container_type::const_iterator;

    container_type M_data;
};

/**
 * @brief Arbitrary-precision integer class using policy-based design.
 *
 * @tparam StoragePolicy  Defines how the sequence of digit blocks is
 * stored in memory.
 * eg., dynamic array(std::vector), fixed-size array, or custom allocator.
 * @tparam BasePolicy  Defines the numeric base (radix) and digit
 * representation.
 * eg., Base10e9 (blocks of 10^9), Base2^32 (binary blocks).
 *
 * @details
 * The BigInteger class provides arithmetic and comparison operations for
 * integers beyond the limits of built-in types. It separates the storage
 * mechanism and digit representation from arithmetic logic using policies,
 * making it modular and adaptable.
 */
template <class StoragePolicy, class BasePolicy>
class BigInteger
{
public:
    using uint = typename BasePolicy::uint;

private:
    StoragePolicy M_storage{};
    bool M_positive{true};
};

// The storage policy defaults to VectorStorage<uint32_t>,
// and the base policy defaults to Base10e9.
using bigint_t = BigInteger<VectorStorage<uint32_t>, Base10e9>;

} // namespace torelis

using bigint = torelis::bigint_t;
